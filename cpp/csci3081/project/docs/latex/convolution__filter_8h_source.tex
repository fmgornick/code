\hypertarget{convolution__filter_8h_source}{}\doxysection{convolution\+\_\+filter.\+h}
\label{convolution__filter_8h_source}\index{/Users/Fletcher/csci3081/repo-\/team-\/0/project/image/include/convolution\_filter.h@{/Users/Fletcher/csci3081/repo-\/team-\/0/project/image/include/convolution\_filter.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 }
\DoxyCodeLine{4 \textcolor{preprocessor}{\#ifndef FFT\_CONVOLUTION\_FILTER\_}}
\DoxyCodeLine{5 \textcolor{preprocessor}{\#define FFT\_CONVOLUTION\_FILTER\_}}
\DoxyCodeLine{6 \textcolor{comment}{/*******************************************************************************}}
\DoxyCodeLine{7 \textcolor{comment}{ * Includes}}
\DoxyCodeLine{8 \textcolor{comment}{ ******************************************************************************/}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{filter_8h}{filter.h}}"{}}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include <bitset>}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <complex>}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <fftw3.h>}}
\DoxyCodeLine{14 \textcolor{comment}{/*******************************************************************************}}
\DoxyCodeLine{15 \textcolor{comment}{ * Class Definitions}}
\DoxyCodeLine{16 \textcolor{comment}{ ******************************************************************************/}}
\DoxyCodeLine{24 \textcolor{keyword}{class }\mbox{\hyperlink{classConvolutionFilter}{ConvolutionFilter}} : \textcolor{keyword}{public} \mbox{\hyperlink{classFilter}{Filter}} \{}
\DoxyCodeLine{25 \textcolor{keyword}{public}:}
\DoxyCodeLine{26   \mbox{\hyperlink{classConvolutionFilter}{ConvolutionFilter}}() \{\}}
\DoxyCodeLine{30   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} \mbox{\hyperlink{classConvolutionFilter_a1422257de3389a478e87daf845ca0d70}{Apply}}(std::vector<Image *> original,}
\DoxyCodeLine{31                      std::vector<Image *> filtered) = 0;}
\DoxyCodeLine{32 }
\DoxyCodeLine{39   \textcolor{keywordtype}{void} \mbox{\hyperlink{classConvolutionFilter_ae2a6513c81b617c894a370b0fda989c7}{ApplyKernel}}(std::vector<Image *> original,}
\DoxyCodeLine{40                    std::vector<Image *> filtered) \{}
\DoxyCodeLine{41     \textcolor{comment}{// get length of the side of our kernel}}
\DoxyCodeLine{42     \textcolor{keywordtype}{int} len = (int)sqrt(kernel\_size);}
\DoxyCodeLine{43     \textcolor{comment}{// padding for image kernel}}
\DoxyCodeLine{44     \textcolor{keywordtype}{int} pad = (len -\/ 1) / 2;}
\DoxyCodeLine{45     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < original.size(); i++) \{}
\DoxyCodeLine{46       \textcolor{comment}{// set filtered image equal to original then iterate through filtered}}
\DoxyCodeLine{47       \textcolor{comment}{// image}}
\DoxyCodeLine{48       *filtered[i] = *original[i];}
\DoxyCodeLine{49       \textcolor{comment}{// create reference to make access easier}}
\DoxyCodeLine{50       \mbox{\hyperlink{classImage}{Image}} \&img = *filtered[i];}
\DoxyCodeLine{51       \textcolor{keywordtype}{int} width = img.\mbox{\hyperlink{classImage_a4ab80d76fd124fd9de9b4fca8ae16186}{GetWidth}}();}
\DoxyCodeLine{52       \textcolor{keywordtype}{int} height = img.\mbox{\hyperlink{classImage_a4d6de643ee334ff52c85da9a62d9297d}{GetHeight}}();}
\DoxyCodeLine{53       \textcolor{keywordtype}{int} image\_size = width * height;}
\DoxyCodeLine{54 }
\DoxyCodeLine{55       \textcolor{comment}{// original image}}
\DoxyCodeLine{56       std::complex<double> *OI = \textcolor{keyword}{new} std::complex<double>[image\_size];}
\DoxyCodeLine{57       \textcolor{comment}{// original kernel}}
\DoxyCodeLine{58       std::complex<double> *OK = \textcolor{keyword}{new} std::complex<double>[image\_size];}
\DoxyCodeLine{59       \textcolor{comment}{// image affter fast-\/fourier transform}}
\DoxyCodeLine{60       std::complex<double> *NI = \textcolor{keyword}{new} std::complex<double>[image\_size];}
\DoxyCodeLine{61       \textcolor{comment}{// kernel affter fast-\/fourier transform}}
\DoxyCodeLine{62       std::complex<double> *NK = \textcolor{keyword}{new} std::complex<double>[image\_size];}
\DoxyCodeLine{63 }
\DoxyCodeLine{64       \textcolor{comment}{// all the above variables reinterpreted as fftw\_complex pointers.  We can}}
\DoxyCodeLine{65       \textcolor{comment}{// do this because they use memory the exact same way, and our fft plans}}
\DoxyCodeLine{66       \textcolor{comment}{// need ffw\_complex arrays as arguments}}
\DoxyCodeLine{67       fftw\_complex *fftOI = \textcolor{keyword}{reinterpret\_cast<}fftw\_complex *\textcolor{keyword}{>}(OI);}
\DoxyCodeLine{68       fftw\_complex *fftOK = \textcolor{keyword}{reinterpret\_cast<}fftw\_complex *\textcolor{keyword}{>}(OK);}
\DoxyCodeLine{69       fftw\_complex *fftNI = \textcolor{keyword}{reinterpret\_cast<}fftw\_complex *\textcolor{keyword}{>}(NI);}
\DoxyCodeLine{70       fftw\_complex *fftNK = \textcolor{keyword}{reinterpret\_cast<}fftw\_complex *\textcolor{keyword}{>}(NK);}
\DoxyCodeLine{71 }
\DoxyCodeLine{72       \mbox{\hyperlink{classColor}{Color}} p;}
\DoxyCodeLine{73       \textcolor{comment}{// set original image equal to the inputed image}}
\DoxyCodeLine{74       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < width; i++) \{}
\DoxyCodeLine{75         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < height; j++) \{}
\DoxyCodeLine{76           img.\mbox{\hyperlink{classImage_a5b9ba06409ad38e86a035ad18d8204d2}{GetPixel}}(i, j, p);}
\DoxyCodeLine{77           OI[i + j * width] = std::complex<double>(p.\mbox{\hyperlink{classColor_a65df51367c71b8d2147e1db240e62429}{getR}}(), 0);}
\DoxyCodeLine{78         \}}
\DoxyCodeLine{79       \}}
\DoxyCodeLine{80 }
\DoxyCodeLine{81       \textcolor{comment}{// take our image of zeros and put our kernel in with 0 padding.  We must}}
\DoxyCodeLine{82       \textcolor{comment}{// circular shif our new kernel for our fft to work properly.  This is}}
\DoxyCodeLine{83       \textcolor{comment}{// done by taking a centered kernal and swapping quadrant 1 with quadrant}}
\DoxyCodeLine{84       \textcolor{comment}{// 3, and swapping quadrant 2 with quadrant 4}}
\DoxyCodeLine{85       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < image\_size; i++)}
\DoxyCodeLine{86         OK[i] = std::complex<double>(0, 0);}
\DoxyCodeLine{87       \textcolor{keywordtype}{int} kernel\_len = std::sqrt(kernel\_size);}
\DoxyCodeLine{88       \textcolor{comment}{// middle value of kernel}}
\DoxyCodeLine{89       \textcolor{keywordtype}{int} m = kernel\_len / 2;}
\DoxyCodeLine{90       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} x = 0; x < kernel\_len; x++) \{}
\DoxyCodeLine{91         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} y = 0; y < kernel\_len; y++) \{}
\DoxyCodeLine{92           \textcolor{comment}{// UPPER LEFT QUADRANT}}
\DoxyCodeLine{93           \textcolor{keywordflow}{if} ((x \% kernel\_len) < m \&\& y < m) \{}
\DoxyCodeLine{94             OK[(width -\/ m + x) + (height -\/ m + y) * width] =}
\DoxyCodeLine{95                 kernel[x + y * kernel\_len] / kernel\_sum;}
\DoxyCodeLine{96           \}}
\DoxyCodeLine{97           \textcolor{comment}{// LOWER RIGHT QUADRANT}}
\DoxyCodeLine{98           \textcolor{keywordflow}{if} ((x \% kernel\_len) >= m \&\& y >= m) \{}
\DoxyCodeLine{99             OK[(x -\/ m) + (y -\/ m) * width] =}
\DoxyCodeLine{100                 kernel[x + y * kernel\_len] / kernel\_sum;}
\DoxyCodeLine{101           \}}
\DoxyCodeLine{102           \textcolor{comment}{// LOWER LEFT QUADRANT}}
\DoxyCodeLine{103           \textcolor{keywordflow}{if} ((x \% kernel\_len) < m \&\& y >= m) \{}
\DoxyCodeLine{104             OK[(width -\/ m + x) + (y -\/ m) * width] =}
\DoxyCodeLine{105                 kernel[x + y * kernel\_len] / kernel\_sum;}
\DoxyCodeLine{106           \}}
\DoxyCodeLine{107           \textcolor{comment}{// UPPER RIGHT QUADRANT}}
\DoxyCodeLine{108           \textcolor{keywordflow}{if} ((x \% kernel\_len) >= m \&\& y < m) \{}
\DoxyCodeLine{109             OK[(x -\/ m) + (height -\/ m + y) * width] =}
\DoxyCodeLine{110                 kernel[x + y * kernel\_len] / kernel\_sum;}
\DoxyCodeLine{111           \}}
\DoxyCodeLine{112         \}}
\DoxyCodeLine{113       \}}
\DoxyCodeLine{114 }
\DoxyCodeLine{115       fftw\_plan plan1;}
\DoxyCodeLine{116       fftw\_plan plan2;}
\DoxyCodeLine{117       fftw\_plan plan3;}
\DoxyCodeLine{118       \textcolor{comment}{// calculate fft on our image}}
\DoxyCodeLine{119       plan1 = fftw\_plan\_dft\_2d(height, width, fftOI, fftNI, 1, FFTW\_ESTIMATE);}
\DoxyCodeLine{120       fftw\_execute(plan1);}
\DoxyCodeLine{121       \textcolor{comment}{// calculate fft on our kernel}}
\DoxyCodeLine{122       plan2 = fftw\_plan\_dft\_2d(height, width, fftOK, fftNK, 1, FFTW\_ESTIMATE);}
\DoxyCodeLine{123       fftw\_execute(plan2);}
\DoxyCodeLine{124 }
\DoxyCodeLine{125       \textcolor{comment}{// convolve image with kernel by multiplying.  This works via the}}
\DoxyCodeLine{126       \textcolor{comment}{// convolution theorem for fourier transforms}}
\DoxyCodeLine{127       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < image\_size; i++) \{}
\DoxyCodeLine{128         NI[i] *= NK[i];}
\DoxyCodeLine{129         OI[i] = 0;}
\DoxyCodeLine{130       \}}
\DoxyCodeLine{131 }
\DoxyCodeLine{132       \textcolor{comment}{// use inverse fft on our convolved image to get our new blurred image}}
\DoxyCodeLine{133       plan3 = fftw\_plan\_dft\_2d(height, width, fftNI, fftOI, -\/1, FFTW\_ESTIMATE);}
\DoxyCodeLine{134       fftw\_execute(plan3);}
\DoxyCodeLine{135       \textcolor{comment}{// delete everything dynamically allocated accept our final image}}
\DoxyCodeLine{136       fftw\_destroy\_plan(plan1);}
\DoxyCodeLine{137       fftw\_destroy\_plan(plan2);}
\DoxyCodeLine{138       fftw\_destroy\_plan(plan3);}
\DoxyCodeLine{139       fftw\_cleanup();}
\DoxyCodeLine{140       \textcolor{keyword}{delete}[] OK;}
\DoxyCodeLine{141       \textcolor{keyword}{delete}[] NI;}
\DoxyCodeLine{142       \textcolor{keyword}{delete}[] NK;}
\DoxyCodeLine{143 }
\DoxyCodeLine{144       \textcolor{comment}{// normalize the values on our image}}
\DoxyCodeLine{145       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < image\_size; i++) \{}
\DoxyCodeLine{146         OI[i] /= width * height;}
\DoxyCodeLine{147       \}}
\DoxyCodeLine{148 }
\DoxyCodeLine{149       \textcolor{keywordtype}{double} val;}
\DoxyCodeLine{150       \textcolor{comment}{// assign our new convolved image with the img reference}}
\DoxyCodeLine{151       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < width; i++) \{}
\DoxyCodeLine{152         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < height; j++) \{}
\DoxyCodeLine{153           val = OI[j * width + i].real();}
\DoxyCodeLine{154           p = \mbox{\hyperlink{classColor}{Color}}(val, val, val);}
\DoxyCodeLine{155           img.\mbox{\hyperlink{classImage_a88e6e6e7cbe530c84c17a342fa2eaf40}{SetPixel}}(i, j, p);}
\DoxyCodeLine{156         \}}
\DoxyCodeLine{157       \}}
\DoxyCodeLine{158       \textcolor{comment}{// fincally, delete the image}}
\DoxyCodeLine{159       \textcolor{keyword}{delete}[] OI;}
\DoxyCodeLine{160     \}}
\DoxyCodeLine{161   \}}
\DoxyCodeLine{166   \mbox{\hyperlink{classConvolutionFilter_a2750951441b1fceb7006192396a706ed}{ConvolutionFilter}}(\textcolor{keyword}{const} \mbox{\hyperlink{classConvolutionFilter}{ConvolutionFilter}} \&filter) \{ *\textcolor{keyword}{this} = filter; \}}
\DoxyCodeLine{170   \textcolor{keywordtype}{void} \mbox{\hyperlink{classConvolutionFilter_a8430a9858e927d8c8cdc5e0b500d1b40}{operator=}}(\textcolor{keyword}{const} \mbox{\hyperlink{classConvolutionFilter}{ConvolutionFilter}} \&filter) \{}
\DoxyCodeLine{171     kernel\_size = filter.kernel\_size;}
\DoxyCodeLine{172     kernel\_sum = filter.kernel\_sum;}
\DoxyCodeLine{173 }
\DoxyCodeLine{174     \textcolor{keyword}{delete} kernel;}
\DoxyCodeLine{175     kernel = \textcolor{keyword}{new} \textcolor{keywordtype}{double}[filter.kernel\_size];}
\DoxyCodeLine{176     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < filter.kernel\_size; i++) \{}
\DoxyCodeLine{177       kernel[i] = filter.kernel[i];}
\DoxyCodeLine{178     \}}
\DoxyCodeLine{179   \}}
\DoxyCodeLine{180 }
\DoxyCodeLine{181 \textcolor{keyword}{protected}:}
\DoxyCodeLine{182   \textcolor{keywordtype}{int} kernel\_size;}
\DoxyCodeLine{183   \textcolor{keywordtype}{double} kernel\_sum;}
\DoxyCodeLine{184   \textcolor{keywordtype}{double} *kernel;}
\DoxyCodeLine{185 \};}
\DoxyCodeLine{186 }
\DoxyCodeLine{187 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !CONVOLUTION\_FILTER\_}}

\end{DoxyCode}
