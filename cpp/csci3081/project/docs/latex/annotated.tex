\section{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\hyperlink{classBattery}{Battery} \\*\hyperlink{classBattery}{Battery} class. \hyperlink{classDrone}{Drone} and \hyperlink{classRobot}{Robot} objects have batteries that deplete over time. This class is used to represent the life of our drone and robot movable entities }{\pageref{classBattery}}{}
\item\contentsline{section}{\hyperlink{classBeelineMovement}{Beeline\+Movement} \\*Beeline movement-\/ will move directly towards a robot given a vector3 position. Extends \hyperlink{classiMovementStrategy}{i\+Movement\+Strategy} so each function overwrites the parent }{\pageref{classBeelineMovement}}{}
\item\contentsline{section}{\hyperlink{classBlobDetectorAdapater}{Blob\+Detector\+Adapater} \\*The Blob\+Detector\+Adapter class that interfaces the \hyperlink{classFilter}{Filter} and Open\+CV. This class scans an image for the orange drone using contours and morphing. If found, the drone data is stored in the pixel in the top left corner }{\pageref{classBlobDetectorAdapater}}{}
\item\contentsline{section}{\hyperlink{classBreadthFirstSearch}{Breadth\+First\+Search} \\*Beeline movement-\/ will move directly towards a robot given a vector3 position. extends \hyperlink{classiMovementStrategy}{i\+Movement\+Strategy} so each function overwrites the parent }{\pageref{classBreadthFirstSearch}}{}
\item\contentsline{section}{\hyperlink{classCamera}{Camera} \\*The camera class. This class can be attached to any entity and act as a camera. When attached to the web app observer, it can receive pictures from the simulation and process the contents of them and return Camera\+Results }{\pageref{classCamera}}{}
\item\contentsline{section}{\hyperlink{structCamera_1_1CameraResult}{Camera\+::\+Camera\+Result} \\*The struct that holds all the information for the camera results once, image processing is completed }{\pageref{structCamera_1_1CameraResult}}{}
\item\contentsline{section}{\hyperlink{classCannyEdgeDetect}{Canny\+Edge\+Detect} \\*The main class for \hyperlink{classCannyEdgeDetect}{Canny\+Edge\+Detect}, extends \hyperlink{classFilter}{Filter}. This basically just applies each of the filters required for the canny edge algorthim in order, }{\pageref{classCannyEdgeDetect}}{}
\item\contentsline{section}{\hyperlink{classColor}{Color} \\*The main class for \hyperlink{classColor}{Color}. We used a color class to make operations for color arithmatic easier. This makes it easy to add mutliply and set colors equal to eachother. The color class also makes it easy to get access to comonly used colors like black and white }{\pageref{classColor}}{}
\item\contentsline{section}{\hyperlink{classCompositeEntityFactory}{Composite\+Entity\+Factory} \\*Composite Entity Factory. This is the class that get\textquotesingle{}s called when creating new entities. Has an entity factory vector member variable to keep track of all the factories. Then when we want to create a new factory, it\textquotesingle{}s added to the vector to be referenced for entity creation }{\pageref{classCompositeEntityFactory}}{}
\item\contentsline{section}{\hyperlink{classCompositeLogger}{Composite\+Logger} \\*Composite logger that uses our other two terminal / csv loggers to record data }{\pageref{classCompositeLogger}}{}
\item\contentsline{section}{\hyperlink{classConsoleLogger}{Console\+Logger} }{\pageref{classConsoleLogger}}{}
\item\contentsline{section}{\hyperlink{classConvolutionFilter}{Convolution\+Filter} \\*The main class for \hyperlink{classConvolutionFilter}{Convolution\+Filter}, extends \hyperlink{classFilter}{Filter}. A basic convolution filter implementation. Each child class will have it\textquotesingle{}s own kernel object and run the given apply kernel function. This class has a lot of extendability as long as the filter algorithm is the same }{\pageref{classConvolutionFilter}}{}
\item\contentsline{section}{\hyperlink{classCSVLogger}{C\+S\+V\+Logger} \\*Logger for csv files. Puts vector information and strategy time information in a comma separated file }{\pageref{classCSVLogger}}{}
\item\contentsline{section}{\hyperlink{classDeapthFirstSearch}{Deapth\+First\+Search} }{\pageref{classDeapthFirstSearch}}{}
\item\contentsline{section}{\hyperlink{classDoubleThresholdFilter}{Double\+Threshold\+Filter} \\*Double Threshold takes in the value of the each pixel and decides if it is a strong or weak pixel based off of its luminencence. It has a strong threshold which makes if white, and a weak threshold that makes it grey }{\pageref{classDoubleThresholdFilter}}{}
\item\contentsline{section}{\hyperlink{classDrone}{Drone} \\*Our actual drone that will be searching for the robot. Contains tons methods to update postion and velocity. Also has many search patterns to find the target robot }{\pageref{classDrone}}{}
\item\contentsline{section}{\hyperlink{classDroneApp}{Drone\+App} }{\pageref{classDroneApp}}{}
\item\contentsline{section}{\hyperlink{classDroneFactory}{Drone\+Factory} \\*\hyperlink{classDrone}{Drone} Factory. When called, it creates a new object of type \hyperlink{classDrone}{Drone}. This factory is never called directly, and is really only used through the composite entity factory }{\pageref{classDroneFactory}}{}
\item\contentsline{section}{\hyperlink{classFactoryTest}{Factory\+Test} \\*Integration tests for our composite factory pattern. These tests checks to see if our factory pattern correctly takes in picojson objects and converts them to an object\textquotesingle{}s member variables }{\pageref{classFactoryTest}}{}
\item\contentsline{section}{\hyperlink{classFilter}{Filter} \\*The main class for \hyperlink{classFilter}{Filter}. This is where all the filters are derived from }{\pageref{classFilter}}{}
\item\contentsline{section}{\hyperlink{classFilterTest}{Filter\+Test} \\*This is a series of unit tests to check how accurate my F\+FT image convolution filter works. In the image directory, there are a series of images with \char`\"{}expected\char`\"{} and \char`\"{}actual\char`\"{} suffixes. The expected comes from an online gaussian blur filter with size 13 kernel and an (i just guessed) standard deviation of 2. The site is \href{https://pinetools.com/blur-image}{\tt https\+://pinetools.\+com/blur-\/image}. The actual output comes from our image\+\_\+processor software, and I check to see how similar the pixel values are by summming up the differences and dividing by the size of the image }{\pageref{classFilterTest}}{}
\item\contentsline{section}{\hyperlink{classFindRobot}{Find\+Robot} \\*This class takes in an image and using the image processing facade runs the logic on images to see if the robot is found }{\pageref{classFindRobot}}{}
\item\contentsline{section}{\hyperlink{classFindRobotTest}{Find\+Robot\+Test} }{\pageref{classFindRobotTest}}{}
\item\contentsline{section}{\hyperlink{classGaussianBlurFilter}{Gaussian\+Blur\+Filter} \\*The main class for \hyperlink{classGaussianBlurFilter}{Gaussian\+Blur\+Filter}, extends \hyperlink{classConvolutionFilter}{Convolution\+Filter}. Creates a 5 x 5 kernel to apply to each pixel and \hyperlink{classConvolutionFilter}{Convolution\+Filter} is used to iterate through the image to apply it. Gaussian Blur is different from Mean Blur in that the representation of each pixel isn\textquotesingle{}t equally distributed like Mean Blur }{\pageref{classGaussianBlurFilter}}{}
\item\contentsline{section}{\hyperlink{classGreyScaleFilter}{Grey\+Scale\+Filter} \\*The main class for \hyperlink{classGreyScaleFilter}{Grey\+Scale\+Filter}, extends \hyperlink{classSimpleFilter}{Simple\+Filter}. Overrides the virtual \hyperlink{classGreyScaleFilter_ac781a1ddd205f2d67d1c08481d5ab2e4}{Apply\+At\+Pixel()} function defined in \hyperlink{classSimpleFilter}{Simple\+Filter}. Just calculates the luminance value of each pixel and sets the pixels rgb values to the luminance }{\pageref{classGreyScaleFilter}}{}
\item\contentsline{section}{\hyperlink{classHospital}{Hospital} \\*Once our robot is found, we\textquotesingle{}re gonna want to rescue it by taking it to the hospital. Thus we need a hospital entity }{\pageref{classHospital}}{}
\item\contentsline{section}{\hyperlink{classHospitalFactory}{Hospital\+Factory} \\*\hyperlink{classHospital}{Hospital} Factory. When called, it creates a new object of type \hyperlink{classHospital}{Hospital}. This factory is never called directly, and is really only used through the composite entity factory }{\pageref{classHospitalFactory}}{}
\item\contentsline{section}{\hyperlink{classHysteresisFilter}{Hysteresis\+Filter} \\*The main class for \hyperlink{classHysteresisFilter}{Hysteresis\+Filter}, extends \hyperlink{classFilter}{Filter}. The hysteresis filter takes the output from the double-\/threshold filter and iterates through, changing all \textquotesingle{}weak\textquotesingle{} pixels into \textquotesingle{}strong\textquotesingle{} pixels if any of the surrounding pixels are \textquotesingle{}strong.\textquotesingle{} If not the pixel is set to black }{\pageref{classHysteresisFilter}}{}
\item\contentsline{section}{\hyperlink{classICameraController}{I\+Camera\+Controller} \\*The \hyperlink{classCamera}{Camera} Controller class controls and allows for monitoring of all cameras }{\pageref{classICameraController}}{}
\item\contentsline{section}{\hyperlink{classICameraObserver}{I\+Camera\+Observer} \\*A \hyperlink{classCamera}{Camera} Observer monitors results from all cameras. It will process the pictures returned asynchronously and act on results }{\pageref{classICameraObserver}}{}
\item\contentsline{section}{\hyperlink{classICameraResult}{I\+Camera\+Result} \\*The result returned from the image processing }{\pageref{classICameraResult}}{}
\item\contentsline{section}{\hyperlink{classiEntity}{i\+Entity} \\*The base class for all entities. Drones, Robots, Hospitals, and Recharge Stations are all entities. This class is abstract, so it\textquotesingle{}s not meant to be instantiated }{\pageref{classiEntity}}{}
\item\contentsline{section}{\hyperlink{classiEntityFactory}{i\+Entity\+Factory} \\*Entity factory interface. Used for our abstract factory method for making new entity objects at run time. Implementation is carried out by \hyperlink{classDroneFactory}{Drone\+Factory}, \hyperlink{classRobotFactory}{Robot\+Factory}, hospital\+Factory, and \hyperlink{classRechargeStationFactory}{Recharge\+Station\+Factory} }{\pageref{classiEntityFactory}}{}
\item\contentsline{section}{\hyperlink{classiLogger}{i\+Logger} \\*Data logger interface. Used to log data on our drone for reasons unbenounced to me. If we wanted to further optimize our drone search and rescue system, we could use a machine learning algorithm to go through our data output files to find the optimal search pattern. This is a composite pattern and has two main logger methods. One for outputing to the terminal screen, and one for saving in a C\+SV file }{\pageref{classiLogger}}{}
\item\contentsline{section}{\hyperlink{classImage}{Image} \\*The main class for \hyperlink{classImage}{Image}. \hyperlink{classImage}{Image} is represented as a big unsigned character array, and alters values inside the image by using the color class. Class just contains getters, setters, and the big 3 }{\pageref{classImage}}{}
\item\contentsline{section}{\hyperlink{classImageProcessingFacade}{Image\+Processing\+Facade} \\*The image processing facade, enables functionality with the image processor with easy to use functions that enable complicated functions with easy use }{\pageref{classImageProcessingFacade}}{}
\item\contentsline{section}{\hyperlink{classiMovableEntity}{i\+Movable\+Entity} \\*Derived class of entity. This is an abstract class that represents entities that move. This class gets implemented by the \hyperlink{classDrone}{Drone} and \hyperlink{classRobot}{Robot} entities }{\pageref{classiMovableEntity}}{}
\item\contentsline{section}{\hyperlink{classiMovementStrategy}{i\+Movement\+Strategy} \\*This is the base class for all movement. Movement strategies can inherit this interface and when it\textquotesingle{}s active the Update method will be called the strategy then must correctly update the position and velocity so that the entity can move accordingly }{\pageref{classiMovementStrategy}}{}
\item\contentsline{section}{\hyperlink{classInvertFilter}{Invert\+Filter} \\*The main class for \hyperlink{classInvertFilter}{Invert\+Filter}, extends \hyperlink{classSimpleFilter}{Simple\+Filter}. A filter that flips the values of each pixel. e.\+g. if a pixel was white after calling \hyperlink{classInvertFilter}{Invert\+Filter} it would be black }{\pageref{classInvertFilter}}{}
\item\contentsline{section}{\hyperlink{classLoggerManager}{Logger\+Manager} \\*Logger singleton class }{\pageref{classLoggerManager}}{}
\item\contentsline{section}{\hyperlink{classMeanBlurFilter}{Mean\+Blur\+Filter} \\*The main class for \hyperlink{classMeanBlurFilter}{Mean\+Blur\+Filter}, extends \hyperlink{classConvolutionFilter}{Convolution\+Filter}. Creates a 3 x 3 kernel with all 1\textquotesingle{}s meaning that each pixel and the surrounding 8 get the same representation for the value of the current pixel. Kernel is applied in \hyperlink{classConvolutionFilter}{Convolution\+Filter} \hyperlink{classMeanBlurFilter_abb7824005c70b04aca6a24760f85cbc1}{Apply()} method }{\pageref{classMeanBlurFilter}}{}
\item\contentsline{section}{\hyperlink{classNonMaxFilter}{Non\+Max\+Filter} \\*The main class for \hyperlink{classNonMaxFilter}{Non\+Max\+Filter}, extends \hyperlink{classFilter}{Filter}. Non\+Max takes in two images, an intensity image and a direction image. This filter scans the image and if intensity of the nearest pixel in the given direction is larger than the current pixel, it will set the current pixel to black. The end result is an image that has thinner lines }{\pageref{classNonMaxFilter}}{}
\item\contentsline{section}{\hyperlink{classPatrolStrategy}{Patrol\+Strategy} \\*Patrol movement-\/ Uses a sinusoidal strategy to move in a wave pattern across the map }{\pageref{classPatrolStrategy}}{}
\item\contentsline{section}{\hyperlink{classPurpleScaleFilter}{Purple\+Scale\+Filter} \\*The main class for \hyperlink{classPurpleScaleFilter}{Purple\+Scale\+Filter}, extends \hyperlink{classSimpleFilter}{Simple\+Filter}. This filter will take an image and \char`\"{}purple scale\char`\"{} it. This means purple will be the only color present in the image and different tones of purple will allow the image to be still be recognizable }{\pageref{classPurpleScaleFilter}}{}
\item\contentsline{section}{\hyperlink{structRawCameraImage}{Raw\+Camera\+Image} \\*A raw camera image stored in jpg format (data) and length is an int }{\pageref{structRawCameraImage}}{}
\item\contentsline{section}{\hyperlink{classRechargeStation}{Recharge\+Station} \\*If our drone runs low on battery and must recharge, then it visits one of these stations to replenish the battery }{\pageref{classRechargeStation}}{}
\item\contentsline{section}{\hyperlink{classRechargeStationFactory}{Recharge\+Station\+Factory} \\*Recharge Station Factory. When called, it creates a new object of type \hyperlink{classRechargeStation}{Recharge\+Station}. This factory is never called directly, and is really only used through the composite entity factory }{\pageref{classRechargeStationFactory}}{}
\item\contentsline{section}{\hyperlink{classRegressionTest}{Regression\+Test} }{\pageref{classRegressionTest}}{}
\item\contentsline{section}{\hyperlink{classRobot}{Robot} \\*\hyperlink{classRobot}{Robot} is a movable entity. This robot will be placed randomly in minneapolis, and our goal is to use our drone to find this robot entity within a given time limit }{\pageref{classRobot}}{}
\item\contentsline{section}{\hyperlink{classRobotFactory}{Robot\+Factory} \\*\hyperlink{classRobot}{Robot} Factory. When called, it creates a new object of type \hyperlink{classRobot}{Robot}. This factory is never called directly, and is really only used through the composite entity factory }{\pageref{classRobotFactory}}{}
\item\contentsline{section}{\hyperlink{classSearchAlgoTest}{Search\+Algo\+Test} }{\pageref{classSearchAlgoTest}}{}
\item\contentsline{section}{\hyperlink{classSearchStrategy}{Search\+Strategy} \\*Partent class for the search strategys }{\pageref{classSearchStrategy}}{}
\item\contentsline{section}{\hyperlink{classSharpeningFilter}{Sharpening\+Filter} \\*This is a convolution filter that uses a kernal found on Wikipedia that sharpens the image. Wikipeidea article\+: \href{https://en.wikipedia.org/wiki/Kernel_(image_processing)}{\tt https\+://en.\+wikipedia.\+org/wiki/\+Kernel\+\_\+(image\+\_\+processing)} }{\pageref{classSharpeningFilter}}{}
\item\contentsline{section}{\hyperlink{classSimpleFilter}{Simple\+Filter} \\*The main class for \hyperlink{classSimpleFilter}{Simple\+Filter}, extends \hyperlink{classFilter}{Filter}. This filter does the brunt of the work when iterating through an image. It\textquotesingle{}s an abstract class, so it\textquotesingle{}s initialized as one of it\textquotesingle{}s derived classes, so when it iterates through the image, it calls the \hyperlink{classSimpleFilter_ad47d7f994aa0f80f9013d689b82a0b92}{Apply\+At\+Pixel()} function that\textquotesingle{}s defined in each of it\textquotesingle{}s derived classes }{\pageref{classSimpleFilter}}{}
\item\contentsline{section}{\hyperlink{classSimulationFacade}{Simulation\+Facade} }{\pageref{classSimulationFacade}}{}
\item\contentsline{section}{\hyperlink{classSobelFilter}{Sobel\+Filter} \\*The main class for \hyperlink{classSobelFilter}{Sobel\+Filter}, extends \hyperlink{classFilter}{Filter}. For this filter, instead of outputing two separate images and pushing them onto the \hyperlink{classImage}{Image} $\ast$ vector, we instead chose to double the size of the image and put the image intensity on top and image gradient on bottom. Both image outputs are found by first applying 2 kernels for x and y intensity. The intensity gradient is found by taking the hypotenuse of of each pixel, and the direction gradient is found by taking the arctangent. More information can be found here\+: \href{https://towardsdatascience.com/canny-edge-detection-step-by-step-in-python-computer-vision-b49c3a2d8123}{\tt https\+://towardsdatascience.\+com/canny-\/edge-\/detection-\/step-\/by-\/step-\/in-\/python-\/computer-\/vision-\/b49c3a2d8123} }{\pageref{classSobelFilter}}{}
\item\contentsline{section}{\hyperlink{classSolarizationFilter}{Solarization\+Filter} \\*The main class for \hyperlink{classSolarizationFilter}{Solarization\+Filter}, extends \hyperlink{classSimpleFilter}{Simple\+Filter}. Solarization filter basically runs the rgb values through a modified sin function to create a pseudo-\/inversion filter }{\pageref{classSolarizationFilter}}{}
\item\contentsline{section}{\hyperlink{structstbi__io__callbacks}{stbi\+\_\+io\+\_\+callbacks} }{\pageref{structstbi__io__callbacks}}{}
\item\contentsline{section}{\hyperlink{classThresholdFilter}{Threshold\+Filter} \\*The main class for \hyperlink{classThresholdFilter}{Threshold\+Filter}, extends \hyperlink{classSimpleFilter}{Simple\+Filter}. Threshold scans the image and if the luminance of the image is above the input threshold it changes the pixel to white, otherwise the pixel turns black. This means the output image only has the colors black and white }{\pageref{classThresholdFilter}}{}
\item\contentsline{section}{\hyperlink{classVector3}{Vector3} \\*Basic 3D vector class. Will be primarily used for entity position and velocity }{\pageref{classVector3}}{}
\item\contentsline{section}{\hyperlink{classWebApp}{Web\+App} \\*A Web Application Sever that communicates with a web page through web sockets }{\pageref{classWebApp}}{}
\end{DoxyCompactList}
