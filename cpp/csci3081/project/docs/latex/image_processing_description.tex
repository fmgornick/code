\hypertarget{image_processing_description_image_processing_section}{}\section{Overview}\label{image_processing_description_image_processing_section}
This is the overview of the image processing library. This image processing library enables our drone to take pictures and analyze them. The core class of the image processing library is the \hyperlink{classImage}{Image} class. This class contains a pointer of data that represents a 4-\/channel image, the ordering of the data is in the R\+G\+BA format. From this image class, the \hyperlink{classFilter}{Filter} class is used to apply transformations to the image, and these can be used for practical purposes. The image library is also integrated with Open\+CV to enable more complex behavior in some filters.

An important idea of the image processing library is the \hyperlink{classFilter}{Filter} class. This is an abstract class that has one Apply function. This “\+Apply” function will take all the Images in its input and run a filter algorithm on them and put the outputs in its output vector. Filters can be broken up into 2 main categories, there are Simple\+Filters and Convolution\+Filters, there are also miscellaneous filters that do not fit into either category.

The \hyperlink{classSimpleFilter}{Simple\+Filter}, takes an image and applies some transformation on 1 pixel at a time and this transformation is the same for every pixel. A \hyperlink{classConvolutionFilter}{Convolution\+Filter} applies a kernel to every pixel of the image. This kernel tells the filter what to do with the neighboring pixels to create a transformation. These two filter types allow the image processor to have a simple \hyperlink{classCannyEdgeDetect}{Canny\+Edge\+Detect} filter. This filter runs a series of simple and convolution filters on the image to identify any edges with white pixels. The \hyperlink{classCannyEdgeDetect}{Canny\+Edge\+Detect} filter is one of the image processors most powerful functions. Looking at the U\+ML diagram for the \hyperlink{classFilter}{Filter} class will show how all functionality from this library derives from that class.

Another really powerful use for the image processor, is the Open\+CV integration. The Blob\+Detector\+Adapter class is a very powerful filter that uses Open\+CV. It uses Open\+CV contours and a morphology algorithm to locate the orange robot in the simulation. This functionality would be very complex to implement with the \hyperlink{classFilter}{Filter} and \hyperlink{classImage}{Image} class on its own so Open\+CV was used to save time and energy. Open\+CV is not used outside of this class, and any class that does Open\+CV should stick with the \hyperlink{classFilter}{Filter} class format and use the adapter design pattern to implement functionality.

From the U\+ML diagram, it is seen that the \hyperlink{classFilter}{Filter} class and \hyperlink{classImage}{Image} class do not interact outside of the Apply function. This is important. An image should not have any reference to any filters, and filters should not have any images as member variables.\hypertarget{image_processing_description_image_processing_contribute}{}\section{How to Contribute}\label{image_processing_description_image_processing_contribute}
If a developer wishes to add to our image processing library the process is easy to catch onto. The only extensions that the image processing library accepts is the creation of new filters. First the developer must decide what filter they would like to implement. From there it must be decided if this filter is a \hyperlink{classSimpleFilter}{Simple\+Filter} or \hyperlink{classConvolutionFilter}{Convolution\+Filter}. The new filter then must extend one of those two classes to use their apply function. However, sometimes a filter is more complex and can simply extend \hyperlink{classFilter}{Filter} if it gains no benefit from extending any other filter class. The process is then just implanting the Apply function to work on the vector of inputs and adding to the vector of outputs. 